### [128. 最长连续序列](https://leetcode-cn.com/problems/longest-consecutive-sequence/)

#### 1. 题目

给定一个未排序的整数数组 `nums` ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。

请你设计并实现时间复杂度为 `O(n)` 的算法解决此问题。

**示例 1：**

```
输入：nums = [100,4,200,1,3,2]
输出：4
解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。
```

**示例 2：**

```
输入：nums = [0,3,7,2,5,8,4,6,0,1]
输出：9
```

**提示：**

- `0 <= nums.length <= 105`
- `-109 <= nums[i] <= 109`

#### 2. 思路

##### 两张哈希表：

- 连续区间的头表：{连续区间的头：连续区间的大小}
- 连续区间的尾表：{连续区间的尾：连续区间的大小}

`nums = [100,4,200,1,3,2]`

- 遍历数组
  - `i=0`
    - `头表={100:1}`		`尾表={100:1}`
    - 头表中没有以101开头的，也没有以99结尾的，无需修改
  - `i=1`
    - `头表={100:1,4:1}`		`尾表={100:1,4:1}`
    - 头表中没有以5开头的，也没有以3结尾的，无需修改
  - `i=2`
    - `头表={100:1,4:1,200:1}`		`尾表={100:1,4:1,200:1}`
    - 头表中没有以201开头的，也没有以199结尾的，无需修改
  - `i=3`
    - `头表={100:1,4:1,200:1,1:1}`		`尾表={100:1,4:1,200:1,1:1}`
    - 头表中没有以2开头的，也没有以0结尾的，无需修改
  - `i=4`
    - `头表={100:1,4:1,200:1,1:1,3:1}`		`尾表={100:1,4:1,200:1,1:1,3:1}`
    - 头表中**有以4开头**的，长度为1，说明有区间`[3:3][4:4]`可以合成
      - 删掉头表中以4开头的记录
      - 删掉尾表中以3结尾的记录
      - 修改头表中3开头的记录长度为2,4结尾的记录长度为2
      - `头表={100:1,200:1,1:1,3:2}`		`尾表={100:1,4:2,200:1,1:1}`
  - `i=5`
    - `头表={100:1,200:1,1:1,3:2,2:2}`		`尾表={100:1,4:2,200:1,1:1,2:2}`
    - 头表中**有以3开头**的，长度为2，说明有区间`[2:2][3:4]`可以合成
      - 删掉头表中以3开头的记录
      - 删掉尾表中以2开头的记录
      - 修改头表中2开头的记录长度为3
      - 修改尾表中4开头的记录长度为3
      - `头表={100:1,200:1,1:1,2:3}`		`尾表={100:1,200:1,1:1,4:3}`
    - 尾表中**有以1结尾**的，长度为1，说明有区间`[1:1][2:4]`可以合成
      - 删掉头表中以2开头的记录
      - 删掉尾表中以1开头的记录
      - 修改头表中1开头的记录长度为4
      - 修改尾表中4开头的记录长度为4
      - `头表={100:1,200:1,1:4}`		`尾表={100:1,200:1,1:1,4:1}`

##### 一张哈希表：

`nums = [100,4,200,1,3,2]`

- `n=0 [100]`:`map={100:1}`
- `n=1 [4]`:`map={100:1,4:1}`
- `n=2 [200]`:`map={100:1,4:1,200:1}`
- `n=3 [1]`:`map={100:1,4:1,200:1,1:1}`
- `n=4 [3]`:
  - `map`中有4的，没有2，所以区间是`[3:4]`修改`map[3]和map[4]`
  - `map={100:1,4:2,200:1,1:1,3:2}`
- `n=5 [2]`:
  - `map`中有`1:1`，也有`3:2`的，所以区间是`[1:4]`
  - 修改`map[1]=4`和`map[4]=4`
  - `map={100:1,4:4,200:1,1:1:4}`

#### 3. 代码

```python
class Solution:
    def longestConsecutive(self, nums: List[int]) -> int:
        if len(nums) == 0: return 0
        hashmap = {}
        hashmap[nums[0]] = 1
        for i in range(1, len(nums)):
            if nums[i] not in hashmap.keys():
                hashmap[nums[i]] = 1
                pre = hashmap[nums[i] - 1] if nums[i] - 1 in hashmap else 0
                after = hashmap[nums[i] + 1] if nums[i] + 1 in hashmap else 0
                hashmap[nums[i] - pre] = pre + after + 1
                hashmap[nums[i] + after] = pre + after + 1
            # print(nums[i], hashmap)
        return max(hashmap.values())        
```

