### [36. 有效的数独](https://leetcode-cn.com/problems/valid-sudoku/) 

#### 1. 题目

请你判断一个 9 x 9 的数独是否有效。只需要 根据以下规则 ，验证已经填入的数字是否有效即可。

1. 数字 1-9 在每一行只能出现一次。
2. 数字 1-9 在每一列只能出现一次。
3. 字 1-9 在每一个以粗实线分隔的 `3x3 `宫内只能出现一次。（请参考示例图）

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/04/12/250px-sudoku-by-l2g-20050714svg.png)

> 示例1 
>
> 输入：`board = 
> [["5","3",".",".","7",".",".",".","."]
> ,["6",".",".","1","9","5",".",".","."]
> ,[".","9","8",".",".",".",".","6","."]
> ,["8",".",".",".","6",".",".",".","3"]
> ,["4",".",".","8",".","3",".",".","1"]
> ,["7",".",".",".","2",".",".",".","6"]
> ,[".","6",".",".",".",".","2","8","."]
> ,[".",".",".","4","1","9",".",".","5"]
> ,[".",".",".",".","8",".",".","7","9"]]`
> 输出：`true`

> 示例2 
>
> 输入：`board = 
> [["8","3",".",".","7",".",".",".","."]
> ,["6",".",".","1","9","5",".",".","."]
> ,[".","9","8",".",".",".",".","6","."]
> ,["8",".",".",".","6",".",".",".","3"]
> ,["4",".",".","8",".","3",".",".","1"]
> ,["7",".",".",".","2",".",".",".","6"]
> ,[".","6",".",".",".",".","2","8","."]
> ,[".",".",".","4","1","9",".",".","5"]
> ,[".",".",".",".","8",".",".","7","9"]]`
> 输出：`false`
> 解释：除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。 但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。

注意：

- 一个有效的数独（部分已被填充）不一定是可解的。
- 只需要根据以上规则，验证已经填入的数字是否有效即可。
  空白格用 '.' 表示。

**提示：**

- `board.length == 9`
- `board[i].length == 9`
- `board[i][j]` 是一位数字（`1-9`）或者 `'.'`

#### 2. 思路——尝试+剪枝
申请布尔类型的三个矩阵

`bool row[9][9]`: `row[2][7]`表示第二行中出现了7

`bool col[9][9]`: `col[2][7]`表示第二列中出现了7

`bool bucket[9][9]`: `bucket[2][7]`表示第个格子中出现了7

遍历检查违规条件

```python
# 通过行列计算求得现在处在第几个宫:
k = 3 * (i // 3) + j // 3
```

#### 3. Code

```python
class Solution:
    def isValidSudoku(self, board: List[List[str]]) -> bool:
        # row[i][num]表示在第i行num数字是否出现
        row = [[0 for i in range(9)] for j in range(9)]
        # col[j][num]表示在第j列num数字是否出现
        col = [[0 for i in range(9)] for j in range(9)]
        # backet[k][num]表示在第k个宫内num数字是否出现
        backet = [[0 for i in range(9)] for j in range(9)]

        # 遍历整个数独
        # 第i行
        for i in range(9):
            # 第j列
            for j in range(9):
                # 通过行列计算求得现在处在第几个宫:
                k = 3 * (i // 3) + j // 3
                # 如果输入的非空
                if board[i][j] != ".":
                    num = int(board[i][j])
                    # 判断是否在三个布尔型数组中出现过
                    if row[i][num - 1] != 0 or col[j][num - 1] != 0 or backet[k][num - 1] != 0:
                        return False
                    row[i][num - 1] = 1
                    col[j][num - 1] = 1
                    backet[k][num - 1] = 1
        return True
```