# [33. 搜索旋转排序数组](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/)

## 题目

整数数组 `nums `按升序排列，数组中的值互不相同 。

在传递给函数之前，`nums` 在预先未知的某个下标 `k（0 <= k < nums.length）`上进行了 旋转，使数组变为 `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]`（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。

给你 旋转后 的数组 `nums` 和一个整数 `target` ，如果 `nums `中存在这个目标值 target ，则返回它的下标，否则返回 -1 。

**示例 1：**

输入：`nums = [4,5,6,7,0,1,2], target = 0`
输出：`4`

**示例 2：**

输入：`nums = [4,5,6,7,0,1,2], target = 3`
输出：`-1`

**示例 3：**

输入：`nums = [1], target = 0`
输出：`-1`

- 提示：

  - `1 <= nums.length <= 5000`

  - `-10^4 <= nums[i] <= 10^4`

  - nums 中的每个值都 独一无二

  - 题目数据保证 nums 在预先未知的某个下标上进行了旋转

  - `-10^4 <= target <= 10^4`



## 思路

有序数组找某个数 使用二分

拿到中点位置的值
- 如果等于target：返回
- 否则：
  - 如果L,M,R三个位置的值全部相同，L+=1（L右移）
    - 直到L和M位置相遇，L,M,R对应的值一直相同 
    - 如果L和M的值变得不同，跳出L右移的循环，开始执行L,M,R位置的值不同的代码
  - L,M,R三个位置的值不完全相同
    - 如果L位置的数大于M位置的数：右侧有序
      - 右侧的最小值：M位置
      - 右侧的最大值：R位置
      - 如果target在[M]和[R]之间：右侧二分
      - 如果target不命中[M]和[R]的范围：左侧二分
    - 如果M位置大于L：左侧有序
      - 左侧最小值：L位置
      - 左侧最大值：R位置
      - 如果target在[L][M]之间：左侧二分
      - 如果target不命中[L][M]：右侧二分
## Code